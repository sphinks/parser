<?php

/**
 * Implements hook_menu()
 */
function parser_menu() {
  $items['parser/check'] = array(
    'page callback' => 'parser_check_code',
    'access arguments' => array('administer site configuration'),
    'type' => MENU_CALLBACK,
  );
  
  $items['admin/structure/parser_jobs/results/%parser_job'] = array(
    'title' => 'Parser results',
    'page callback' => 'parser_result_page',
    'page arguments' => array(4),
    'access arguments' => array('administer site configuration'),
    'type' => MENU_CALLBACK,
  );
  
  return $items;
}

/**
 * Implements hook_entity_info()
 */
function parser_entity_info() {
  return array(
    'parser_job' => array(
      'label' => t('Job parsing'),
      'entity class' => 'Entity',
      'controller class' => 'EntityAPIController',
      'base table' => 'parser_jobs',
      'entity keys' => array(
        'id' => 'jid',
        'label' => 'title'
      ),
      'admin ui' => array(
        'path' => 'admin/structure/parser_jobs'
      ),
      'uri callback' => 'parser_job_uri',
      'access callback' => 'parser_job_access',
      'module' => 'parser',
      'exportable' => TRUE,
    ),
  );
}

/**
 * Check acces rights
 */
function parser_job_access($op, $entity, $account = NULL, $entity_type = 'parser_job') {
  return user_access('administer site configuration');
}
 
/**
 * Load entity object by id
 */
function parser_job_load($id) {
  $result = entity_load('parser_job', array($id));
  return $result ? reset($result) : FALSE;
}

/**
 * Parser job uri callback
 */
function parser_job_uri($job) {
  return array(
    'path' => 'admin/structure/parser_jobs/manage/' . $job->jid,
  );
}

/**
 * Menu callback
 */
function parser_job_form($form, &$form_state, $job) {
  $check_button = array('#field_prefix' => '<input type="button" value="проверить" class="form-submit check-button" />');
  $fields_code = isset($job->fields_code) ? $job->fields_code : array();
  $entity_types = entity_get_info();
  $fields_info = field_info_fields();
  $formats = filter_formats();
  $weight = 0;
  
  $entity_type_options = array();
  foreach ($entity_types as $entity_type => $entity_info) {
    $entity_type_options[$entity_type] = $entity_info['label'];
  }
  
  $entity_type_value = isset($job->entity_type) ? $job->entity_type : 'node';
  if (isset($form_state['values']['entity_type'])) {
    $entity_type_value = $form_state['values']['entity_type'];
  }
  
  $bundle_options = array();
  foreach ($entity_types[$entity_type_value]['bundles'] as $bundle_name => $bundle_info) {
    $bundle_options[$bundle_name] = $bundle_info['label'];
  }
  
  $bundle_value = (isset($job->bundle) && isset($bundle_options[$job->bundle])) ? $job->bundle : key($bundle_options);
  if (isset($form_state['values']['bundle']) && isset($bundle_options[$form_state['values']['bundle']])) {
    $bundle_value = $form_state['values']['bundle'];
  }
  
  $entity_keys = $entity_types[$entity_type_value]['entity keys'];
  $bundle_key = $entity_keys['bundle'];
  $label_key = isset($entity_keys['label']) ? $entity_keys['label'] : '';
  
  list($entity_properties, $entity_properties_fields) = _parser_get_entity_properties($entity_type_value, $bundle_value);
  if ($entity_type_value == 'taxonomy_term') {
    unset($entity_properties['vocabulary']);
  }
  if (isset($entity_properties[$bundle_key])) {
    unset($entity_properties[$bundle_key]);
  }
  
  $fields_instances = field_info_instances($entity_type_value, $bundle_value);
  
  $format_options = array();
  foreach ($formats as $format) {
    $format_options[$format->format] = $format->name;
  }
  
  $form['title'] = array(
    '#type' => 'textfield',
    '#title' => 'Название задания',
    '#description' => 'Будет отображаться в списке с заданиями. Пример заполнения: <code>Парсинг проектов на drupal.org</code>',
    '#required' => TRUE,
    '#default_value' => isset($job->title) ? $job->title : '',
    '#maxlength' => 255,
  );
  
  $form['start_url'] = array(
    '#type' => 'textfield',
    '#title' => 'Стартовый URL',
    '#description' => 'Адрес, с которого парсер начнёт работу. Пример заполнения: <code>http://drupal.org/project/modules</code>',
    '#required' => TRUE,
    '#default_value' => isset($job->start_url) ? $job->start_url : '',
    '#maxlength' => 255,
  );
  
  $form['test_url'] = array(
    '#type' => 'textfield',
    '#title' => 'URL тестовой страницы',
    '#description' => 'Адрес любой страницы, попадающей под условие парсинга, которая будет использоваться для проверки работоспособности кода.',
    '#required' => TRUE,
    '#default_value' => isset($job->test_url) ? $job->test_url : '',
    '#maxlength' => 255,
  );
  
  $form['depth'] = array(
    '#type' => 'textfield',
    '#title' => 'Глубина',
    '#description' => 'Глубина, на которую парсер будет ходить по ссылкам. Например 1 означает, что будет распарсен стартовый адрес и страницы на которые он ссылается, т.е. парсер пройдёт вглубь на 1 уровень относительно стартовой страницы.',
    '#required' => TRUE,
    '#default_value' => isset($job->depth) ? $job->depth : '',
    '#size' => 5,
  );
  
  $form['white_list'] = array(
    '#type' => 'textarea',
    '#title' => 'Белый список адресов',
    '#description' => 'Маски адресов, по которым будет разрешено ходить парсеру. Каждая маска на новой строке. Оставьте пустым, если парсеру разрешено ходить по всем найденным ссылкам. Пример заполнения: <code>http://drupal.org/project/*</code>',
    '#default_value' => isset($job->white_list) ? $job->white_list : '',
    '#rows' => 3,
  );

  $form['black_list'] = array(
    '#type' => 'textarea',
    '#title' => 'Чёрный список адресов',
    '#description' => 'Маски адресов, по которым будет запрещено ходить парсеру. Каждая маска на новой строке. Пример заполнения: <code>http://drupal.org/project/uc_*</code>',
    '#default_value' => isset($job->black_list) ? $job->black_list : '',
    '#rows' => 3,
  );
  
  $form['check_code'] = array(
    '#type' => 'textarea',
    '#title' => 'Код проверки для дальнейшего парсинга страницы',
    '#description' => '
      PHP код без тегов &lt;?php и ?&gt;, который должен вернуть TRUE если страницу нужно парсить в ноду. Доступные переменные: $page - html код страницы, $doc - объект phpQuery, $page_url -
      адрес страницы без учёта редиректов. Пример заполнения: <code>return ($doc->find(\'.class-name\')->length() > 0);</code><br />Если возвращаемое значение будет числом или строкой, то оно
      будет расценено как идентификатор страницы (аналог nid). Этот идентификатор будет сохранён в бд и позволит избежать дублей материалов, которые доступны по нескольким URL.
    ',
    '#default_value' => isset($job->check_code) ? $job->check_code : '',
    '#rows' => 3,
    '#resizable' => FALSE,
  ) + $check_button;
  
  // Entity type
  $form['entity_type'] = array(
    '#type' => 'select',
    '#title' => 'Тип сущности (entity type)',
    '#description' => 'Выберите тип сущности, который будет создавать парсер.',
    '#options' => $entity_type_options,
    '#default_value' => isset($job->entity_type) ? $job->entity_type : 'node',
    '#required' => TRUE,
    '#ajax' => array('callback' => 'parser_job_form_entity_type_ajax_callback'),
    '#disabled' => isset($job->jid) && db_select('parser_map')->condition('jid', $job->jid)->countQuery()->execute()->fetchField() ? TRUE : FALSE,
  );
  
  // Bundle
  $form['bundle'] = array(
    '#type' => 'select',
    '#title' => 'Подтип сущности (bundle)',
    '#description' => 'Выберите подтип сущности, который будет создавать парсер.',
    '#options' => $bundle_options,
    '#default_value' => isset($job->bundle) ? $job->bundle : key($bundle_options),
    '#required' => TRUE,
    '#prefix' => '<div id="edit-bundle-wrapper">',
    '#suffix' => '</div>',
    '#ajax' => array(
      'callback' => 'parser_job_form_fields_ajax_callback',
      'wrapper' => 'fields-code-wrapper',
    ),
  );
  
  $form['fields_wrapper'] = array(
    '#prefix' => '<div id="fields-code-wrapper">',
    '#suffix' => '</div>',
    '#type' => 'fieldset',
    '#title' => 'Поля',
    '#description' => '
      <p>Поля заполняются без обёртки кода в &lt;?php и ?&gt;. Во всех полях доступны следующие переменные:</p>
      <p>
        $doc - объект phpQuery<br />
        $page - html код страницы<br />
        $page_url - адрес страницы без учёта редиректов<br />
        $entity - объект сущности<br />
        $entity_wrapper - entity metadata wrapper<br />
      </p>
      <p>Оставьте textarea пустым, если поле заполнять не нужно.</p>
    ',
  );
  
  $form['fields_wrapper']['vertical_tabs'] = array('#type' => 'vertical_tabs');
  $form['fields_wrapper']['fields_code'] = array('#tree' => TRUE);
  
  // Properties & Fields
  foreach (($entity_properties + $entity_properties_fields) as $property_name => $property_info) {
    if (!empty($property_info['computed']) || !isset($property_info['setter callback'])) {
      continue;
    }
    
    $fieldset_name = $property_name . '_fieldset';
    $field_type = isset($property_info['type']) ? $property_info['type'] : '';
    $this_property_is_field = isset($property_info['field']);
    $this_property_is_multi_value = ($this_property_is_field && $fields_info[$property_name]['cardinality'] != 1);
    
    $form['fields_wrapper']['fields_code'][$fieldset_name] = array(
      '#type' => 'fieldset',
      '#title' => $property_info['label'] . ' (' . $property_name . ')' . (!empty($property_info['required']) ? ' *' : ''),
      '#description' => isset($property_info['description']) ? $property_info['description'] : '',
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#weight' => (!empty($property_info['required']) || !empty($property_info['field'])) ? $weight : $weight + 100,
      '#group' => 'vertical_tabs',
    );
    
    $description = 'PHP код, который должен вернуть ' . ($this_property_is_multi_value ? 'массив значений' : 'значение') . ' поля';
    // Simle field or property
    if (!isset($property_info['property info'])) {
      $description .= ($field_type ? ' (тип: ' . $field_type . ').' : '.');
    }
    // Compound field or property
    else {
      if ($this_property_is_multi_value) {
        $description .= '. Каждое значение должно быть';
      }
      $description .= ' в формате:<br /><br /><code>array(<br />' . _parser_get_field_structure($property_info) . ')</code>';
    }
    
    $form['fields_wrapper']['fields_code'][$fieldset_name][$property_name] = array(
      '#type' => 'textarea',
      '#title' => 'PHP код',
      '#description' => $description,
      '#default_value' => isset($fields_code[$property_name]) ? $fields_code[$property_name] : '',
      '#rows' => 3,
      '#resizable' => FALSE,
      '#required' => !empty($property_info['required']),
    ) + $check_button;
    
    
    $form['fields_wrapper']['fields_code'][$fieldset_name]['techical_info_fieldset'] = array(
      '#type' => 'fieldset',
      '#title' => 'Техническая информация о поле',
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
    );
    
    if (function_exists('kprint_r')) {
      $techical_info = kprint_r($property_info, TRUE, 'entity_get_property_info()');
      if ($this_property_is_field) {
        $techical_info .= kprint_r($fields_info[$property_name], TRUE, 'field_info_fields()');
        $techical_info .= kprint_r($fields_instances[$property_name], TRUE, 'field_info_instances()');
      }
    }
    else {
      $techical_info = 'Установите модуль <a href="http://drupal.org/project/devel" target="_blank">Devel</a>.';
    }
      
    $form['fields_wrapper']['fields_code'][$fieldset_name]['techical_info_fieldset']['techical_info'] = array(
      '#markup' => $techical_info,
    );
    
    $weight++;
  }
  
  $form['advanced_settings'] = array(
    '#type' => 'fieldset',
    '#title' => 'Дополнительные настройки',
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );
  
  $form['advanced_settings']['parse_limit'] = array(
    '#type' => 'textfield',
    '#title' => 'Ограничить число создаваемых/обновляемых сущностей',
    '#description' => 'Максимальное число сущностей, которое сможет создать/обновить парсер. Применяется в осномном при тестировании задания. Оставьте пустым, если ограничения не нужны.',
    '#default_value' => !empty($job->parse_limit) ? $job->parse_limit : '',
    '#size' => 5,
  );
  
  $form['advanced_settings']['site_charset'] = array(
    '#type' => 'select',
    '#title' => 'Кодировка сайта',
    '#description' => 'Выберите кодировку, которая используется на удалённом сайте. Рекомендуется автоопределение.',
    '#options' => array('auto' => 'Автоопределение', 'UTF-8' => 'UTF-8', 'WINDOWS-1251' => 'WINDOWS-1251'),
    '#default_value' => isset($job->site_charset) ? $job->site_charset : 'auto',
  );
  
  $form['advanced_settings']['charset_fix'] = array(
    '#type' => 'checkbox',
    '#title' => 'Передавать кодировку в конструктор phpQuery',
    '#description' => 'Отметьте, если возникают проблемы с кодировкой. Костыль!',
    '#default_value' => isset($job->charset_fix) ? $job->charset_fix : FALSE,
  );
  
  $form['advanced_settings']['only_this_domen'] = array(
    '#type' => 'checkbox',
    '#title' => 'Парсить только с этого же домена',
    '#description' => 'Отметьте, если хотите чтобы парсер работал только на домене, указанном в поле "Стартовый URL".',
    '#default_value' => isset($job->only_this_domen) ? $job->only_this_domen : TRUE,
  );
  
  $form['advanced_settings']['save_url'] = array(
    '#type' => 'checkbox',
    '#title' => 'Сохранять адреса',
    '#description' => 'Отметьте, если хотите, чтобы у нод были такие же адреса, как на оригинальном сайте. Не включайте эту опцию если на оригинальном сайте не используется ЧПУ (т.е. в адресах есть символ "?")',
    '#default_value' => isset($job->save_url) && module_exists('path') ? $job->save_url : 0,
    '#disabled' => !module_exists('path'),
  );
  
  $form['advanced_settings']['no_update'] = array(
    '#type' => 'checkbox',
    '#title' => 'Не обновлять сущности',
    '#description' => 'Отметьте, если не хотите обновлять сущности, созданные в предыдущие запуски этого задания.',
    '#default_value' => isset($job->no_update) ? $job->no_update : 0,
  );
  
  $form['advanced_settings']['clear_watchdog'] = array(
    '#type' => 'checkbox',
    '#title' => 'Очистить системный журнал',
    '#description' => 'Отметьте, если хотите очистить системный журнал (watchdog) перед началом парсинга.',
    '#default_value' => 0,
  );
  
  $form['advanced_settings']['prepare_code'] = array(
    '#type' => 'textarea',
    '#title' => 'Пост-обработка сущности',
    '#description' => '
      Код, который будет выполнен перед вызовом entity_save(). Доступные переменные:
        $entity - объект сущности,
        $entity_wrapper - entity metadata wrapper,
        $page - html код страницы,
        $doc - объект phpQuery.
      Пример заполнения: <code>$entity->title = \'new title\';</code>
    ',
    '#default_value' => isset($job->prepare_code) ? $job->prepare_code : '',
    '#rows' => 3,
    '#resizable' => FALSE,
  );
  
  $form['actions'] = array(
    '#type' => 'actions',
  );
  
  $form['actions']['submit'] = array(
    '#type' => 'submit',
    '#value' => 'Сохранить задание',
  );
  
  $form['actions']['submit_and_start'] = array(
    '#type' => 'submit',
    '#value' => 'Сохранить задание и Начать парсинг',
  );
  
  _parser_set_rows($form);
  
  $parser_path = drupal_get_path('module', 'parser');
  $form['#attached']['library'][] = array('system', 'ui.dialog');
  $form['#attached']['library'][] = array('parser', 'codemirror');
  $form['#attached']['css'][] = $parser_path . '/parser.css';
  $form['#attached']['js'][] = $parser_path . '/parser.js';

  return $form;
}

/**
 * Ajax callback
 */
function parser_job_form_entity_type_ajax_callback($form, $form_state) {
  $commands[] = ajax_command_insert('#edit-bundle-wrapper', drupal_render($form['bundle']));
  $commands[] = ajax_command_insert('#fields-code-wrapper', drupal_render($form['fields_wrapper']));
  return array('#type' => 'ajax', '#commands' => $commands);
}

/**
 * Ajax callback
 */
function parser_job_form_fields_ajax_callback($form, $form_state) {
  return $form['fields_wrapper'];
}

/**
 * Job form submit callback
 */
function parser_job_form_submit(&$form, &$form_state) {
  $clicked_button = $form_state['clicked_button']['#value'];
  $fields = field_info_fields();
  $fields_code = array();
  
  if (isset($form_state['values']['fields_code'])) {
    foreach ($form_state['values']['fields_code'] as $fieldset) {
      foreach ($fieldset as $field_name => $field_code) {
        $fields_code[$field_name] = $field_code;
      }
    }
    $fields_code = array_diff($fields_code, array(''));
  }
  $form_state['values']['fields_code'] = $fields_code;
  
  if (!$form_state['values']['parse_limit']) {
    $form_state['values']['parse_limit'] = 0;
  }
  
  $job = entity_ui_form_submit_build_entity($form, $form_state);
  $job->save();

  // Save
  if ($form_state['clicked_button']['#value'] == $form_state['values']['submit']) {
    drupal_set_message('Задание сохранено.');
    $form_state['redirect'] = 'admin/structure/parser_jobs/manage/' . $job->jid;
  }
  // Save and Run
  else {
    parser_run_batch($job, request_path() == 'admin/structure/parser_jobs/add');
  }
}

/**
 * Init batch process and run parsing
 */
function parser_run_batch($job, $redirect = FALSE) {
  if (is_numeric($job)) {
    $job = parser_job_load($job);
  }
  
  _parser_url_delete_all();
  _parser_url_add($job->start_url);

  if (!empty($job->clear_watchdog)) {
    db_delete('watchdog')->execute();
  }
  
  return batch_set(array(
    'title' => 'Парсинг',
    'progress_message' => '',
    'operations' => array(
      array('parser_parse', array($job, $redirect)),
    ),
    'finished' => 'parser_finished',
  ));
}

/**
 * Parse page
 */
function parser_parse($job, $redirect, &$context) {
  if (empty($context['sandbox'])) {
    $context['sandbox']['progress'] = 0;
    $context['sandbox']['entity_ids'] = array();
    $context['sandbox']['created_entities'] = 0;
    $context['results']['jid'] = $job->jid;
    $context['results']['time_start'] = time();
    $context['results']['created_entities'] = 0;
    $context['results']['updated_entities'] = 0;
    $context['results']['files_from_http'] = 0;
    $context['results']['files_from_http_error'] = 0;
    $context['results']['files_from_cache'] = 0;
    $context['results']['redirect'] = $redirect;
  }
  
  $url = _parser_url_get_not_parsed();
  $page_url = $url->url;
  $page_url_parsed = parse_url($page_url);
  $page = _parser_get_page_by_url($page_url, $job->site_charset, $context['results']);
  $doc = _parser_create_phpquery($page, $job->charset_fix);
  $entity_id = parser_get_entity_id_by_url($page_url, $job->jid);
  $entity_type_info = entity_get_info($job->entity_type);
  $page_key = '';
  
  if ($url->depth < $job->depth) {
    // Find links
    foreach ($doc->find('a') as $a) {
      $href = pq($a)->attr('href');
      $href_full = _parser_get_full_url($href, $page_url);
      
      if (!$href) {
        continue;
      }
      if (drupal_substr($href, 0, 1) == '#') {
        continue;
      }
      if (preg_match('#^([a-z]+)://#', $href, $matches) && !in_array($matches[1], array('http', 'https'))) {
        continue;
      }
      if (strpos($href, 'javascript:') === 0 || strpos($href, 'mailto:') === 0) {
        continue;
      }
      if ($job->white_list && !drupal_match_path($href_full, $job->white_list)) {
        continue;
      }
      if ($job->black_list && drupal_match_path($href_full, $job->black_list)) {
        continue;
      }
      if ($job->only_this_domen) {
        $page_url_parsed_host = str_replace('www.', '', $page_url_parsed['host']);
        $href_host = str_replace('www.', '', parse_url($href_full, PHP_URL_HOST));
        if ($page_url_parsed_host != $href_host) {
          continue;
        }
      }

      _parser_url_add($href_full, $url->depth + 1, $page_url, $href);
    }
  }

  // Decide - parse cur page or not
  $allowed_parse = TRUE;
  if (!$page) {
    $allowed_parse = FALSE;
  }
  if ($allowed_parse && $job->parse_limit && $context['sandbox']['created_entities'] >= $job->parse_limit) {
    $allowed_parse = FALSE;
  }
  if ($allowed_parse && $job->check_code) {
    $allowed_parse = eval($job->check_code);
    if ($allowed_parse && !is_bool($allowed_parse)) {
      $page_key = $allowed_parse;
      if (!$entity_id) {
        $entity_id = parser_get_entity_id_by_page_key($page_key, $job->jid);
      }
    }
  }
  if ($allowed_parse && $entity_id && in_array($entity_id, $context['sandbox']['entity_ids'])) {
    $allowed_parse = FALSE;
  }
  if ($allowed_parse && $job->no_update && $entity_id) {
    $allowed_parse = FALSE;
  }
  
  // Parse page
  if ($allowed_parse) {
    module_load_include('inc', 'parser', 'parser_prepare_field');
    module_load_include('inc', 'parser', 'parser_prepare_entity');
    
    $fields_info = field_info_fields();
    $fields_instances = field_info_instances($job->entity_type, $job->bundle);
    list($entity_properties, $entity_properties_fields) = _parser_get_entity_properties($job->entity_type, $job->bundle);
    
    // Load entity
    if ($entity_id) {
      $entity = current(entity_load($job->entity_type, array($entity_id)));
      $context['results']['updated_entities']++;
    }
    // Create entity object
    if (!$entity_id || !$entity) {
      $entity = entity_create($job->entity_type, array($entity_type_info['entity keys']['bundle'] => $job->bundle));
      $context['results']['created_entities']++;
    }
    
    $entity_wrapper = entity_metadata_wrapper($job->entity_type, $entity);
    
    // Populate properties and fields
    foreach ($job->fields_code as $property_name => $php_code) {
      if (!$php_code) {
        continue;
      }
      
      $result = eval($php_code);
      $property_is_field = isset($entity_properties_fields[$property_name]);
      $property_info = $property_is_field ? $entity_properties_fields[$property_name] : $entity_properties[$property_name];
      $property_is_compound = isset($property_info['property info']);
      $field_info = $property_is_field ? $fields_info[$property_name] : NULL;
      $field_is_multi_value = ($property_is_field && $field_info['cardinality'] != 1);
      
      // Prepare fields
      if ($property_is_field && $result) {
        $function = '_parser_prepare_field_' . $field_info['type'];
        if (function_exists($function)) {
          if ($field_is_multi_value) {
            foreach (array_keys($result) as $key) {
              $function($result[$key], $field_info, $fields_instances[$property_name], $entity, $job, $page_url, $context['results']);
            }
          }
          else {
            $function($result, $field_info, $fields_instances[$property_name], $entity, $job, $page_url, $context['results']);
          }
        }
      }
      
      _parser_set_property($entity_wrapper, $property_name, $result, $property_is_compound, $field_is_multi_value);
    }
    
    // Set Path alias
    if ($job->save_url && !isset($entity->path)) {
      $alias = trim($page_url_parsed['path'], '/');
      $alias = str_replace('%20', ' ', $alias);
      $entity->path = array(
        'alias' => $alias,
        'language' => LANGUAGE_NONE,
      );
    }
    
    // Prepare entity
    $function = '_parser_prepare_entity_' . $job->entity_type;
    if (function_exists($function)) {
      $function($entity, $entity_wrapper);
    }
    if ($job->prepare_code) {
      eval($job->prepare_code);
    }
    
    try {
      $entity_wrapper->save();
    }
    catch (Exception $e) {
      _parser_watchdog('Ошибка при сохранении сущности: ' . $e->getMessage() . '. <b>Адрес:</b> ' . check_plain($page_url), $entity);
    }
    
    if ($entity_id = $entity_wrapper->getIdentifier()) {
      _parser_map_save(array(
        'entity_id' => $entity_id,
        'jid' => $job->jid,
        'url' => $page_url,
        'page_key' => $page_key,
      ));
      
      $context['sandbox']['entity_ids'][] = $entity_id;
      $context['sandbox']['created_entities']++;
    }
  }
  
  _parser_url_mark_parsed($page_url);

  $context['sandbox']['max'] = _parser_url_count();
  $context['sandbox']['progress']++;
  $context['message'] = '
    Завершён парсинг страницы глубиной ' . $url->depth . ' <em>' . $page_url . '</em><br />
    Обработано страниц: ' . $context['sandbox']['progress'] . '<br />
    Страниц в очереди: ' . ($context['sandbox']['max'] - $context['sandbox']['progress']) . '<br />
    Создано сущностей: ' . $context['results']['created_entities'] . '<br />
    Обновлено сущностей: ' . $context['results']['updated_entities'] . '<br />
    Скачано <abbr title="Страниц и файлов">url</abbr>: ' . $context['results']['files_from_http'] . '<br />
    Не удалось скачать url: ' . $context['results']['files_from_http_error'] . '<br />
    Url взято из кэша: ' . $context['results']['files_from_cache'] . '<br />
    Затраченное время: ' . gmdate('H:i:s', time() - $context['results']['time_start']) . '
  ';

  if ($job->parse_limit && $context['sandbox']['created_entities'] >= $job->parse_limit) {
    $context['finished'] = 1;
  }
  elseif ($context['sandbox']['progress'] <= $context['sandbox']['max']) {
    $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['max'];
  }
}

/**
 * Site is parsed
 */
function parser_finished($success, $results, $operations) {
  drupal_set_message('
    ' . ($success ? 'Парсинг завершён' : 'Парсинг завершён с ошибками') . '.
    Обработано страниц: ' . _parser_url_count(TRUE) . '.
    Скачано URL: ' . $results['files_from_http'] . '.
    Не удалось скачать URL: ' . $results['files_from_http_error'] . '.
    Создано сущностей: ' . l($results['created_entities'], 'admin/structure/parser_jobs/results/' . $results['jid']) . '.
    Обновлено сущностей: ' . l($results['updated_entities'], 'admin/structure/parser_jobs/results/' . $results['jid']) . '.
    Затрачено времени: ' . gmdate('H:i:s', time() - $results['time_start']) . '.
    ' . l('Посмотреть системный журнал', 'admin/reports/dblog') . '
  ');
  if ($results['redirect']) {
    drupal_goto('admin/structure/parser_jobs/manage/' . $results['jid']);
  }
}

/**
 * Implements of hook_entity_delete().
 * Delete record from {parser_map} table
 */
function parser_entity_delete($entity, $entity_type) {
  $entity_id = entity_id($entity_type, $entity);
    
  $query = db_select('parser_map', 'pm');
  $query->fields('pm', array('jid'));
  $query->innerJoin('parser_jobs', 'pj', 'pj.jid = pm.jid');
  $query->condition('pj.entity_type', $entity_type);
  $query->condition('pm.entity_id', $entity_id);
  $jid = $query->execute()->fetchField();
    
  db_delete('parser_map')
    ->condition('jid', $jid)
    ->condition('entity_id', $entity_id)
    ->execute();
}

/**
 * Implements of hook_entity_view().
 * Show link to original page. Only for admin.
 */
function parser_entity_view($entity, $entity_type, $view_mode, $langcode) {
  $entity_id = entity_id($entity_type, $entity);
  
  if ($view_mode == 'full' && $GLOBALS['user']->uid == 1 && ($url = _parser_get_url_by_entity_id($entity_id))) {
	preg_match("/http:\/\/(.+\..{2,3})\//", $url, $matches);
	$show_url = $matches[1];
    $entity->content['parser_url'] = array(
      '#markup' => '<p>Источник: ' . l($show_url, $url, array('attributes' => array('target' => '_blank'))) . '</p>', 
      '#weight' => 100, 
    );
  }
}

/**
 * Check php code
 */
function parser_check_code() {
  $params = array('test_url', 'site_charset', 'charset_fix', 'field_name', 'field_value');
  foreach ($params as $param) {
    if (!isset($_POST[$param]) || $_POST[$param] === '') {
      echo 'bad params';
      return NULL;
    }
  }
  
  $page = _parser_get_page_by_url($_POST['test_url'], $_POST['site_charset']);
  $page_url = $_POST['test_url'];
  $doc = _parser_create_phpquery($page, $_POST['charset_fix']);
  $result = eval($_POST['field_value']);
  
  echo print_r($result, TRUE);
}

/**
 * Result page
 */
function parser_result_page($job) {
  $entity_info = entity_get_info($job->entity_type);
  $label_key = $entity_info['entity keys']['label'];
  
  $query = db_select('parser_map', 'pm');
  $query->fields('pm', array('entity_id', 'url', 'page_key'));
  $query->fields('e', array($label_key));
  $query->innerJoin($entity_info['base table'], 'e', 'e.' . $entity_info['entity keys']['id'] . ' = pm.entity_id');
  $query->condition('jid', $job->jid);
  $result = $query->execute();
  
  $rows = array();
  foreach ($result as $row) {
    $entity = current(entity_load($job->entity_type, array($row->entity_id)));
    $uri = entity_uri($job->entity_type, $entity);
    
    $rows[] = array(
      l($row->url, $row->url),
      l($row->{$label_key}, $uri['path'], $uri['options']),
      $row->page_key,
    );
  }
    
  return theme('table', array(
    'header' => array('URL', $label_key, t('Identifier')),
    'rows' => $rows,
    'empty' => 'Пусто...',
  ));
}

/**
 * Implements of hook_form_FORM_ID_alter()
 */
function parser_form_parser_job_overview_form_alter(&$form, $form_state) {
  $form['table']['#header'][2]['colspan'] = 5;
  
  foreach ($form['table']['#rows'] as &$row) {
    $row[] = l(t('results'), 'admin/structure/parser_jobs/results/' . $row[0]['data']['#name']);
  }
}

/**
 * Implements of hook_library().
 */
function parser_library() {
  $parser_path = drupal_get_path('module', 'parser');
    
  $libraries['codemirror'] = array(
    'title' => 'CodeMirror',
    'website' => 'http://codemirror.net/',
    'version' => '2.13',
    'js' => array(
      $parser_path . '/codemirror2/lib/codemirror.js' => array(),
      $parser_path . '/codemirror2/mode/clike/clike.js' => array(),
      $parser_path . '/codemirror2/mode/php/php.js' => array(),
    ),
    'css' => array(
      $parser_path . '/codemirror2/lib/codemirror.css' => array(),
      $parser_path . '/codemirror2/theme/default.css' => array(),
    ),
  );

  return $libraries;
}

/**
 * Return entity id by URL
 */
function parser_get_entity_id_by_url($url, $jid = NULL) {
  $query = db_select('parser_map', 'pn')
    ->fields('pn', array('entity_id'))
    ->condition('url', $url)
    ->range(0, 1);
    
  if ($jid) {
    $query->condition('jid', $jid);
  }
  
  return $query->execute()->fetchField();
}

/**
 * Return entity id by Page Key
 */
function parser_get_entity_id_by_page_key($page_key, $jid = NULL) {
  $query = db_select('parser_map', 'pn')
    ->fields('pn', array('entity_id'))
    ->condition('page_key', $page_key)
    ->range(0, 1);

  if ($jid) {
    $query->condition('jid', $jid);
  }
  
  return $query->execute()->fetchField();
}

/**
 * Implements hook_entity_property_info_alter()
 */
function parser_entity_property_info_alter(&$info) {
  foreach ($info as $entity_type => $properties) {
    if (isset($properties['bundles'])) {
      foreach ($properties['bundles'] as $bundle => $bundle_properties) {
        foreach ($bundle_properties['properties'] as $property_name => $property_info) {
          _parser_set_format_setter_callback($info[$entity_type]['bundles'][$bundle]['properties'][$property_name]);
        }
      }
    }
    
    foreach ($properties['properties'] as $property_name => $property_info) {
      _parser_set_format_setter_callback($info[$entity_type]['properties'][$property_name]);
    }
  }
}

/**
 * Find images in html, download and change href
 */
function parser_download_images($html, $page_url, $path = 'public://images', &$stat = NULL) {
  $doc = _parser_create_phpquery($html);
  
  foreach ($doc->find('img') as $img) {
    $image_url = _parser_get_full_url(pq($img)->attr('src'), $page_url);
    $image_url_parsed = parse_url($image_url);
    $local_image_name = ltrim($image_url_parsed['path'], '/');
    $local_image_name = str_replace('/', '-', $local_image_name);
    
    if (!file_exists($path . '/' . $local_image_name)) {
      // Download image to cache
      $cache_file_uri = _parser_download_url_to_cache($image_url, $stat);
      if (!$cache_file_uri) {
        continue;
      }
      
      // Copy image from cache
      $file = _parser_copy_file($cache_file_uri, $path . '/' . $local_image_name);
      if ($file) {
        $file->status = FILE_STATUS_PERMANENT;
        file_save($file);
      }
    }
    
    $new_src = file_create_url($path . '/' . $local_image_name);
    $new_src = drupal_substr($new_src, drupal_strlen($GLOBALS['base_root']));
    pq($img)->attr('src', $new_src);
  }
  
  return $doc->html();
}

/**
 * Set setter callback
 */
function _parser_set_format_setter_callback(&$property_info) {
  if (
    isset($property_info['type']) &&
    ($property_info['type'] == 'text_formatted' || $property_info['type'] == 'list<text_formatted>') &&
    isset($property_info['property info']['format']) && 
    !isset($property_info['property info']['format']['setter callback'])
  ) {
    $property_info['property info']['format']['setter callback'] = 'entity_property_verbatim_set';
  }
}

/**
 * Get URL info
 */
function _parser_url_get($url) {
  return db_select('parser_urls', 'pu')
    ->fields('pu')
    ->condition('url', $url)
    ->execute()
    ->fetchObject();
}

/**
 * Get first not parsed URL info
 */
function _parser_url_get_not_parsed() {
  return db_select('parser_urls', 'pu')
    ->fields('pu')
    ->condition('parsed', 0)
    ->range(0, 1)
    ->execute()
    ->fetchObject();
}

/**
 * Adding URL to database
 */
function _parser_url_add($url, $depth = 0, $page_url = '', $href = '') {
  if (!_parser_url_get($url)) {
    db_insert('parser_urls')
      ->fields(array(
        'url' => $url,
        'depth' => $depth,
        'page_url' => $page_url,
        'href' => $href,
      ))
      ->execute();
  }
}

/**
 * Mark URL as parsed
 */
function _parser_url_mark_parsed($url) {
  db_update('parser_urls')
    ->fields(array('parsed' => 1))
    ->condition('url', $url)
    ->execute();
}

/**
 * Delete all URLs from database
 */
function _parser_url_delete_all() {
  db_truncate('parser_urls')->execute();
}

/**
 * Get count not parsed URLs
 */
function _parser_url_count($parsed = null) {
  $query = db_select('parser_urls', 'pu');
  if (!is_null($parsed)) {
    $query->condition('pu.parsed', $parsed);
  }
  return $query->countQuery()->execute()->fetchField();
}

/**
 * Return page html by URL
 */
function _parser_get_page_by_url($url, $charset = 'auto', &$results = NULL) {
  $page_cache_uri = _parser_download_url_to_cache($url, $results);
  if (!$page_cache_uri) {
    return NULL;
  }
  $page = file_get_contents($page_cache_uri);
  
  // Convert charset
  if ($charset == 'auto') {
    if (preg_match('# content="text/html; charset=(.+)"#isU', $page, $matches) && drupal_strtolower($matches[1]) != 'utf-8') {
      $page = iconv($matches[1], 'UTF-8//IGNORE', $page);
      $page = str_ireplace(
        ' content="text/html; charset=' . $matches[1] . '"',
        ' content="text/html; charset=utf-8"',
        $page
      );
    }
  }
  else if ($charset != 'UTF-8') {
    $page = iconv($charset, 'UTF-8//IGNORE', $page);
  }
      
  return $page;
}

/**
 * Download remote url to cache and return cache uri
 */
function _parser_download_url_to_cache($url, &$stat = NULL) {
  $cache_uri = 'public://parser_cache/' . md5($url);
  
  if (!file_exists($cache_uri)) {
    $options = array('headers' => array('User-Agent' => 'Opera/9.80 (Windows NT 6.1; U; ru) Presto/2.8.131 Version/11.10')); 
    $result = drupal_http_request($url, $options);
    if ($result->code == 303 && !empty($result->headers['location'])) {
      $result = drupal_http_request($result->headers['location'], $options);
    }
    
    if (!empty($result->error)) {
      _parser_watchdog('Ошибка при закачке ' . check_plain($url) . ': ' . check_plain($result->error) . (isset($result->data) ? ', <b>Результат</b>: ' . check_plain(drupal_substr($result->data, 0, 1000)) : ''));
      if ($stat) {
        $stat['files_from_http_error']++;
      }
      return NULL;
    }
    if (!$result->data) {
      _parser_watchdog('Ошибка при закачке ' . check_plain($url) . ': сервер не возвратил данных.');
      if ($stat) {
        $stat['files_from_http_error']++;
      }
      return NULL;
    }
    
    file_unmanaged_save_data($result->data, $cache_uri);
    if ($stat) {
      $stat['files_from_http']++;
    }
    return $cache_uri;
  }
  else {
    if ($stat) {
      $stat['files_from_cache']++;
    }
    return $cache_uri;
  }
}

/**
 * Add row in {parser_map} table
 */
function _parser_map_save($record) {
  db_merge('parser_map')
    ->key(array('entity_id' => $record['entity_id']))
    ->fields(array(
      'jid' => $record['jid'],
      'url' => $record['url'],
      'page_key' => $record['page_key'],
    ))
    ->execute();
}

/**
 * Return URL by entity id
 */
function _parser_get_url_by_entity_id($entity_id, $jid = NULL) {
  $query = db_select('parser_map', 'pn')
    ->fields('pn', array('url'))
    ->condition('entity_id', $entity_id);
    
  if ($jid) {
    $query->condition('jid', $jid);
  }
  
  return $query->execute()->fetchField();
}

/**
 * Return row count
 */
function _parser_get_rows($text) {
  $count = substr_count(trim($text), "\n") + 1;
  return $count > 3 ? $count : 3;
}

/**
 * Set row count
 */
function _parser_set_rows(&$form) {
  foreach (element_children($form) as $element) {
    if (isset($form[$element]['#type']) && $form[$element]['#type'] == 'textarea') {
      $form[$element]['#rows'] = _parser_get_rows($form[$element]['#default_value']);
    }
    else {
      _parser_set_rows($form[$element]);
    }
  }
}

/**
 * Return full url
 */
function _parser_get_full_url($url, $page_url) {
  $url = trim($url);
  $url = preg_replace('/#.*/', '', $url);
  $page_url_parsed = parse_url($page_url);
  if (!isset($page_url_parsed['path'])) {
    $page_url_parsed['path'] = '/';
  }

  // example: //wikimedia.org/dir/image.png
  if (substr($url, 0, 2) == '//') {
    $url = $page_url_parsed['scheme'] . ':' . $url;
  }
  // example: /dir/image.png
  elseif (substr($url, 0, 1) == '/') {
    $url = $page_url_parsed['scheme'] . '://' . $page_url_parsed['host'] . $url;
  }
  // example: dir/image.png
  elseif (strpos($url, 'http') !== 0) {
    $path = preg_replace('#/[^/]+$#', '', $page_url_parsed['path']);
    $path = trim($path, '/');
    if ($path) {
      $path .= '/';
    }
    $url = $page_url_parsed['scheme'] . '://' . $page_url_parsed['host'] . '/' . $path . $url;
  }
  
  $url = str_replace(' ', '+', $url);
  
  return $url;
}

/**
 * Create phpQuery object
 */
function _parser_create_phpquery($html, $charset_fix = FALSE) {
  require_once('phpQuery/phpQuery/phpQuery.php');
  return phpQuery::newDocumentHTML($html, $charset_fix ? 'utf8' : NULL);
}

/**
 * Return example field structure
 */
function _parser_get_field_structure($field_info, $spaces = 2) {
  $strucure = '';
  foreach ($field_info['property info'] as $property_name => $property_info) {
    if (!isset($property_info['setter callback'])) {
      continue;
    }
    $strucure .= _parcer_spaces($spaces) . "'$property_name' => \${$property_name}, // " . $property_info['label'] . ' (' . $property_info['type'] . ', ' . (isset($property_info['required']) ? 'required' : 'optional') . ')<br />';
  }
  return $strucure;
}

/**
 * Return spaces
 */
function _parcer_spaces($count) {
  return str_repeat('&nbsp;', $count);
}

/**
 * Set entity property
 */
function _parser_set_property($entity_wrapper, $property_name, $property_value, $property_is_compound, $property_is_multi_value) {
  // Multi-value compound property
  if ($property_is_multi_value && $property_is_compound && $property_value) {
    foreach ($property_value as $delta => $property_item) {
      foreach ($property_item as $sub_property_name => $sub_property_value) {
        try {
          $entity_wrapper->{$property_name}[$delta]->{$sub_property_name} = $sub_property_value;
        }
        catch (Exception $e) {
          _parser_watchdog('Ошибка при записи в $entity_wrapper->' . $property_name . '[' . $delta . ']->' . $sub_property_name . ': ' . $e->getMessage(), $sub_property_value);
        }
      }
    }
  }
  // Single-value compound property
  else if (!$property_is_multi_value && $property_is_compound && $property_value) {
    foreach ($property_value as $sub_property_name => $sub_property_value) {
      try {
        $entity_wrapper->{$property_name}->{$sub_property_name} = $sub_property_value;
      }
      catch (Exception $e) {
        _parser_watchdog('Ошибка при записи в $entity_wrapper->' . $property_name . '->' . $sub_property_name . ': ' . $e->getMessage(), $sub_property_value);
      }
    }
  }
  // Multi-value simple property
  else if ($property_is_multi_value && !$property_is_compound && $property_value) {
    foreach ($property_value as $delta => $property_item) {
      try {
        $entity_wrapper->{$property_name}[$delta] = $property_item;
      }
      catch (Exception $e) {
        _parser_watchdog('Ошибка при записи в $entity_wrapper->' . $property_name . '[' . $delta . ']: ' . $e->getMessage(), $property_item);
      }
    }
  }
  // Single-value simple property
  else if (!$property_is_multi_value && !$property_is_compound) {
    try {
      $entity_wrapper->{$property_name} = $property_value;
    }
    catch (Exception $e) {
      _parser_watchdog('Ошибка при записи в $entity_wrapper->' . $property_name . ': ' . $e->getMessage(), $property_value);
    }
  }
}

/**
 * Add error to watchdog
 */
function _parser_watchdog($text, $object) {
  watchdog('parser', $text . '<br />Value:<pre>' . check_plain(print_r($object, TRUE)) . '</pre>', array(), WATCHDOG_ERROR);
}

/**
 * Return entity type properties
 */
function _parser_get_entity_properties($entity_type, $bundle) {
  $entity_properties_and_fields = entity_get_property_info($entity_type);
  $entity_properties = $entity_properties_and_fields['properties'];
  $entity_properties_fields = isset($entity_properties_and_fields['bundles'])
    ? $entity_properties_and_fields['bundles'][$bundle]['properties']
    : array();
  return array($entity_properties, $entity_properties_fields);
}

/**
 * Copy file from cache and return file object
 */
function _parser_copy_file($from_uri, $to_uri) {
  $file = (object)array(
    'uid' => $GLOBALS['user']->uid,
    'uri' => $from_uri,
    'filename' => drupal_basename($to_uri),
    'filemime' => file_get_mimetype($from_uri),
  );
  $file_path = file_stream_wrapper_uri_normalize($to_uri);
  $file = file_copy($file, $file_path);
  if (!$file) {
    _parser_watchdog('Ошибка при копировании файла <i>' . $file->uri  . '</i> в <i>' . $file_path . '</i>.');
  }
  
  return $file;
}

